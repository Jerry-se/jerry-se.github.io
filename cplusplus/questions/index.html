<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Jerry">
        <link rel="canonical" href="https://jerry-se.github.io/cplusplus/questions/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Questions - Jerry's blog</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <link href="../../css/extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/django.min.js"></script>
        <script>hljs.highlightAll();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-274394082"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', "G-274394082");
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Jerry's blog</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../../markdown/" class="nav-link">Markdown</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">C/C++ <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../lambda/" class="dropdown-item">Lambda</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Questions</a>
</li>
                                    
<li>
    <a href="../bit_xor/" class="dropdown-item">Bit Xor</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Go <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../go/go/" class="dropdown-item">Go tutorial</a>
</li>
                                    
<li>
    <a href="../../go/install/" class="dropdown-item">Install</a>
</li>
                                    
<li>
    <a href="../../go/getting_started/" class="dropdown-item">Getting started</a>
</li>
                                    
<li>
    <a href="../../go/create_module/" class="dropdown-item">Create module</a>
</li>
                                    
<li>
    <a href="../../go/workspaces/" class="dropdown-item">Workspaces</a>
</li>
                                    
<li>
    <a href="../../go/web_service_gin/" class="dropdown-item">Web service gin</a>
</li>
                                    
<li>
    <a href="../../go/generics/" class="dropdown-item">Generics</a>
</li>
                                    
<li>
    <a href="../../go/writing_web_app/" class="dropdown-item">Writing Web app</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Tool <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../git/git/" class="dropdown-item">Git</a>
</li>
                                    
<li>
    <a href="../../git/git_lfs/" class="dropdown-item">Git LFS</a>
</li>
                                    
<li>
    <a href="../../git/gitea/" class="dropdown-item">Gitea</a>
</li>
                                    
<li>
    <a href="../../tool/frp/" class="dropdown-item">Frp</a>
</li>
                                    
<li>
    <a href="../../tool/v2ray/" class="dropdown-item">V2Ray</a>
</li>
                                    
<li>
    <a href="../../tool/activation_keys/" class="dropdown-item">Activation</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Python <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../python/build_blogs_with_pelican/" class="dropdown-item">Pelican</a>
</li>
                                    
<li>
    <a href="../../python/mkdocs/" class="dropdown-item">MkDocs</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Linux 开发 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../linux_development/docker/" class="dropdown-item">docker</a>
</li>
                                    
<li>
    <a href="../../linux_development/coredump/" class="dropdown-item">coredump</a>
</li>
                                    
<li>
    <a href="../../linux_development/ipmi/" class="dropdown-item">ipmi</a>
</li>
                                    
<li>
    <a href="../../linux_development/make_deb_package/" class="dropdown-item">制作 deb 安装包</a>
</li>
                                    
<li>
    <a href="../../linux_development/samba/" class="dropdown-item">Samba</a>
</li>
                                    
<li>
    <a href="../../linux_development/scsi/" class="dropdown-item">SCSI</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Windows 开发 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../windows_development/character_encoding/" class="dropdown-item">字符编码</a>
</li>
                                    
<li>
    <a href="../../windows_development/autostart/" class="dropdown-item">开机启动</a>
</li>
                                    
<li>
    <a href="../../windows_development/automatic_power_up/" class="dropdown-item">自动开机</a>
</li>
                                </ul>
                            </li>
                            <li class="navitem">
                                <a href="../../sitemap/" class="nav-link">Index</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../lambda/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../bit_xor/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#common-interview-questions" class="nav-link">C/C++ 常见面试题</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#difference-between-c-and-cpp" class="nav-link">C 和 C++ 的区别</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#difference-between-pointer-and-reference" class="nav-link">指针和引用的区别</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#difference-between-malloc-and-new" class="nav-link">malloc 和 new，free 和 delete 的区别</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#extern-c" class="nav-link">extern C 的作用</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#commonly-used-containers" class="nav-link">常用的容器有哪些</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#volatile-type-qualifier" class="nav-link">volatile 关键字的作用</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#type-conversion" class="nav-link">有哪几种强制类型转换以及使用场景</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#cpp11-new-features" class="nav-link">C++11 新特性</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#cpp20-new-features" class="nav-link">C++ 20 新特性</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#three-characteristics-of-cpp" class="nav-link">C++ 的三大特性</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#polymorphism-in-cpp" class="nav-link">C++的多态实现原理</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#virtual-function" class="nav-link">什么是虚函数</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#pure-virtual-function" class="nav-link">什么是纯虚函数</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#sizeof-vtable-pointer" class="nav-link">虚表指针的大小</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#vtable-pointer" class="nav-link">虚函数表的存放内容</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#can-constructor-be-virtual" class="nav-link">构造函数可以是虚函数吗</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#can-destructor-be-virtual" class="nav-link">析构函数可以是虚函数吗</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#empty-class" class="nav-link">一个空类会生成哪些函数</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#left-value-right-value" class="nav-link">左值和右值</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#smart-pointer" class="nav-link">什么是智能指针，有哪几种，作用，实现原理</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#circular-dependency" class="nav-link">如何避免循环依赖</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#unique_ptr-stdmove" class="nav-link">unique_ptr 中 std::move() 作用</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#static-keywords" class="nav-link">static 关键字的使用</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#const-keywords" class="nav-link">const 关键字的使用</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#diffences-between-define-and-const" class="nav-link">define 和 const 的区别</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#object-oriented-design-principles" class="nav-link">面向对象的设计原则</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#compilation-process" class="nav-link">C++ 编译过程</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="common-interview-questions">C/C++ 常见面试题<a class="headerlink" href="#common-interview-questions" title="Permanent link"></a></h1>
<p>本人总结的常见面试题</p>
<hr />
<h2 id="difference-between-c-and-cpp">C 和 C++ 的区别<a class="headerlink" href="#difference-between-c-and-cpp" title="Permanent link"></a></h2>
<p>除了面向对象与面向过程这个回答之外，C 与 C++ 的真正区别在哪里？</p>
<p>这几年不管是社团实习工作面试都有被问到这个问题。但是「面向对象以及面向过程」这个回答似乎都不是最好或者最完善的答案。</p>
<p>所以这个问题根本没有简单的答案，选3个角度谈就能写3篇论文。简单说说几个常见的误区。</p>
<ul>
<li>误区1：C++是面向对象的C？并不是。现代C++是至少四种编程范式的集合体（面向过程，面向对象，泛型编程和元编程，函数式编程等，实际可能不止4种）。说C++是面向对象语言，是一种很瞧不起C++的说法，因为面向对象仅仅是C++的多种范式之一。</li>
<li>误区2：C是面向过程语言？不能这么说。在面向对象方面，C语言提供的语法支持比较薄弱，但这不表示C是面向过程的语言。用C语言写面向对象程序不仅不弱，甚至会有一些优势。世界上有很多非常重要的、大量使用面向对象技术的软件是用纯C写的。例如Linux的图形界面GNOME。</li>
<li>
<p>误区3：C是C++的子集，C支持的语法C++都支持。不对。C++在最初设计时是基于C的，绝大多数语法都兼容。但是，在一些细节却重要的地方，二者差别非常大。例如，C语言的函数指针非常神奇：</p>
<pre><code>int (*pfunc)();
</code></pre>
<p>看上去pfunc可以指向返回值为int，无参数的函数？并不是。实际上pfunc可以指向任意返回值为int的函数，无论参数是什么。而无参的情况必须写明参数为void：</p>
<pre><code>int (*pfunc)(void);
</code></pre>
<p>C语言不必指定参数类型也可以引用函数，这一点让C语言具有很强的动态特性。而C++去除了这种设计，因为破坏了类型安全。同理，C语言常用的(void*)转换在C++中也在很大程度上摒弃了，理由也是类型不安全。哪个设计好哪个不好不重要。重要的是：C并不是C++的子集，C++也不是C的超集。它们在语法、设计理念、常用写法方面均有不同，到今天二者的差别越来越大。</p>
</li>
<li>
<p>误区4：C++比C功能多，所以C++运行比C慢一点。不对。虽然C++加入了很多很多功能，但由于绝大多数功能都是在编译器上做手脚，大多情况下仅影响编译速度，而不影响运行速度。而且泛型、元编程等技术用好了，能让C++的程序运行的更快。反而是C，由于大量使用不定类型的转换，损失的性能相当可观。</p>
</li>
</ul>
<p>总之，C与C++的区别远不是一段话能够讲清楚。</p>
<h2 id="difference-between-pointer-and-reference">指针和引用的区别<a class="headerlink" href="#difference-between-pointer-and-reference" title="Permanent link"></a></h2>
<ol>
<li>指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。"sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；</li>
<li>引用必须被初始化，指针不必。</li>
<li>引用初始化以后不能被改变，指针可以改变所指的对象。</li>
<li>不存在指向空值的引用，但是存在指向空值的指针。</li>
<li>引用的创建和销毁不会调用类的拷贝构造函数和析构函数。</li>
<li>指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）。</li>
</ol>
<h2 id="difference-between-malloc-and-new">malloc 和 new，free 和 delete 的区别<a class="headerlink" href="#difference-between-malloc-and-new" title="Permanent link"></a></h2>
<ol>
<li>new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。</li>
<li>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</li>
<li>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</li>
<li>new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</li>
<li>new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</li>
<li>C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。</li>
<li>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</li>
</ol>
<div class="admonition note">
<p class="admonition-title">PS:</p>
<p>在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；</p>
<p>在C中，C内存区分为堆、栈、全局/静态存储区、常量存储区；</p>
</div>
<h2 id="extern-c">extern C 的作用<a class="headerlink" href="#extern-c" title="Permanent link"></a></h2>
<p>主要作用就是为了能够正确实现C++代码调用其他C语言代码。被extern "C"修饰的变量和函数是按照C语言方式进行编译和链接的。</p>
<p>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern "C"就是其中的一个策略。</p>
<p>被extern "C"限定的函数或变量是extern类型的，extern是C/C++语言中表明函数和全局变量的作用范围的关键字，该关键字告诉编译器，其申明的函数和变量可以在本模块或其他模块中使用。</p>
<p>extern对应的关键字是static，static表明变量或者函数只能在本模块中使用，因此，被static修饰的变量或者函数不可能被extern C修饰。</p>
<h2 id="commonly-used-containers">常用的容器有哪些<a class="headerlink" href="#commonly-used-containers" title="Permanent link"></a></h2>
<p>顺序性容器</p>
<ol>
<li>vector: 是一段连续的内存地址，基于数组实现，其提供了自动内存管理功能（采用了STL普遍的内存管理器allocator），可以动态改变对象长度，提供随机访问。在尾部添加和删除元素的时间是常数的，但在头部或中间就是线性时间。</li>
<li>list: 非连续的内存，基于链表实现，属于循环双向链表，目的是实现快速插入和删除，但是随即访问却是比较慢。</li>
<li>forward_list: 实现了单链表，不可反转。相比于list，forward_list更简单，更紧凑，但功能也更少。</li>
<li>deque: 双端队列（double-ended queue），支持随机访问，与vector类似，主要区别在于，从deque对象的开始位置插入和删除元素的时间也是常数的，所以若多数操作发生在序列的起始和结尾处，则应考虑使用deque。为实现在deque两端执行插入和删除操作的时间为常数时间这一目的，deque对象的设计比vector更为复杂，因此，尽管二者都提供对元素的随机访问和在序列中部执行线性时间的插入和删除操作，但vector容器执行这些操作时速度更快些。</li>
<li>queue: 是一个适配器类，先进先出。queue模板让底层类（默认是deque）展示典型的队列接口。queue模板的限制比deque更多，它不仅不允许随机访问队列元素，甚至不允许遍历队列。与队列相同，只能将元素添加到队尾、从队首删除元素、查看队首和队尾的值、检查元素数目和测试队列是否为空。</li>
<li>priority_queue: 是另一个适配器类，支持的操作与queue相同，但最高优先级元素总是第一个出列。两者之间的主要区别在于，在priority_queue中，最大的元素被移到队首。内部区别在于，默认的底层类是vector。可以修改用于确定哪个元素放到队首的比较方式，方法是提供一个可选的构造函数参数。</li>
<li>stack: 与queue相似，stack也是一个适配器类，它给底层类（默认情况下为vector）提供了典型的栈接口，后进先出。</li>
</ol>
<p>关联容器: 主要有map和set。map是key-value形式的，set是单值。map和set只能存放唯一的key值，multimap和multiset可以存放多个相同的key值。底层都基于树型结构。</p>
<ol>
<li>map/multimap: map容器提供一个键值对(key-value)容器，map与multimap差别仅仅在于multimap允许一个键对应多个值。对于迭代器来说，可以修改实值，而不能修改key。map会根据key自动排序。</li>
<li>set/multiset: set的含义是集合，它是一个有序的容器，里面的元素都是排序好的支持插入、删除、查找等操作，就像一个集合一样，所有的操作都是严格在logn时间内完成，效率非常高。set和multiset的区别是,set插入的元素不能相同，但是multiset可以相同，set默认是自动排序的，使用方法类似list。</li>
</ol>
<h2 id="volatile-type-qualifier">volatile 关键字的作用<a class="headerlink" href="#volatile-type-qualifier" title="Permanent link"></a></h2>
<p>volatile指出变量是随时可能发生变化的，与volatile变量有关的运算，不要进行编译优化，以免出错，如在C语言中，volatile关键字可以用来提醒编译器它后面所定义的变量随时有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。</p>
<p>VC++ 在产生release版可执行码时会 进行编译优化，加volatile关键字的变量有关的运算，将不进行编译优化。</p>
<p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p>
<ol>
<li>并行设备的硬件寄存器（如：状态寄存器）</li>
<li>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</li>
<li>多线程应用中被几个任务共享的变量 回答不出这个问题的人是不会被雇佣的。</li>
</ol>
<p>搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。</p>
<h2 id="type-conversion">有哪几种强制类型转换以及使用场景<a class="headerlink" href="#type-conversion" title="Permanent link"></a></h2>
<ol>
<li>
<p>C风格强制类型转换，如</p>
<pre><code>Type b = (Type)a;
</code></pre>
</li>
<li>
<p>C++风格强制类型转换，有static_cast、const_cast、reinterpret_cast和dynamic_cast四种。</p>
<ul>
<li>static_cast: 比C风格的强制类型转换要安全很多，有很大程度上的类型安全检查。但结果可能会出错，而且编译器不会给出错误信息。有明显缺点的，那就是无法消除const和volatile属性。</li>
<li>const_cast: 去除掉const或volitale属性。不是用于去除变量的常量性，而是去除指向常量对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用，并且const_cast不支持不同类型指针或引用之间的转换，比如说float<em>转换成int</em>是不允许的，相差的话只能差const或volatile属性。</li>
<li>reinterpret_cast: 意为“重新解释”，它是C++中最接近于C风格强制类型转换的一个关键字。它让程序员能够将一种对象类型转换为另一种，不管它们是否相关。可以先使用reinterpret_cast把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值。使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，和C风格极其相似，实际上reinterpret_cast的出现就是为了让编译器强制接受static_cast不允许的类型转换，因此使用的时候要谨而慎之。</li>
<li>dynamic_cast: 是运行时处理的，运行时会进行类型检查（这点和static_cast差异较大）。不能用于内置基本数据类型的强制转换，只能对指针或引用进行强制转换。如果转换成功的话返回的是指向类的指针或引用，转换失败的话则会返回nullptr。进行上行转换时，与static_cast的效果是完全一样的，进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。而且dynamic_cast运行时的类型检查需要有运行时类型信息，这个信息是存储在类的虚表中的。</li>
</ul>
</li>
</ol>
<h2 id="cpp11-new-features">C++11 新特性<a class="headerlink" href="#cpp11-new-features" title="Permanent link"></a></h2>
<p>简单说一些常见的C++11的新特性。</p>
<ol>
<li>
<p>nullptr: 空指针，用来替代NULL。</p>
<p>传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 <code>((void*)0)</code>，有些则会直接将其定义为 0。C++ 不允许直接将 void * 隐式转换到其他类型，但如果 NULL 被定义为 <code>((void*)0)</code>，那么当编译 <code>char *ch = NULL;</code> 时，NULL 只好被定义为 0。而这依然会产生问题，将导致了 C++ 中重载特性会发生混乱，考虑：</p>
<pre><code>void foo(char *);
void foo(int);
</code></pre>
<p>对于这两个函数来说，如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直观。为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。</p>
<p>nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。当需要使用 NULL 时候，养成直接使用 nullptr的习惯。</p>
<p>在没有C++ 11的nullptr的时候，我们怎么解决避免这个问题呢？我们可以自己实现一个:</p>
<pre><code>const
class nullptr_t
{
public:
    template&lt;class T&gt;           operator T*() const { return 0; }
    template&lt;class C, class T&gt;  operator T C::*() const { return 0; }
private:
    void operator&amp;() const;
} nullptr = {};
#undef NULL
#define NULL nullptr
</code></pre>
</li>
<li>
<p>类型推导: C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。</p>
<p>auto 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 register 并存。在传统 C++ 中，如果一个变量没有声明为 register 变量，将自动被视为一个 auto 变量。而随着 register 被弃用，对 auto 的语义变更也就非常自然了。</p>
<p>使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。在以前我们需要这样来书写一个迭代器：</p>
<pre><code>for(vector&lt;int&gt;::const_iterator itr = vec.cbegin(); itr != vec.cend(); ++itr)
</code></pre>
<p>而有了 auto 之后可以：</p>
<pre><code>for(auto itr = vec.cbegin(); itr != vec.cend(); ++itr);
</code></pre>
<p>decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 sizeof 很相似：decltype(表达式)</p>
<pre><code>auto x = 1;
auto y = 2;
decltype(x+y) z;
</code></pre>
</li>
<li>
<p>基于范围的 for 循环</p>
<p>C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句。
最常用的 std::vector 遍历将从原来的样子：</p>
<pre><code>for(std::vector&lt;int&gt;::iterator i = arr.begin(); i != arr.end(); ++i) {
    std::cout &lt;&lt; *i &lt;&lt; std::endl;
}
</code></pre>
<p>使用范围for循环变得非常的简单：</p>
<pre><code>// &amp; 启用了引用
for(auto &amp;i : arr) {    
    std::cout &lt;&lt; i &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p>初始化列表</p>
<p>C++11 提供了统一的语法来初始化任意的对象，例如：</p>
<pre><code>struct A {
    int a;
    float b;
};
struct B {

    B(int _a, float _b): a(_a), b(_b) {}
private:
    int a;
    float b;
};

A a {1, 1.1};    // 统一的初始化语法
B b {2, 2.2};
</code></pre>
</li>
<li>
<p>Lambda 表达式</p>
<p>Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。基本语法如下：</p>
<pre><code>[ caputrue ] ( params ) opt -&gt; ret { body; };
</code></pre>
<ol>
<li>capture是捕获列表；</li>
<li>params是参数表；(选填)</li>
<li>opt是函数选项；可以填mutable,exception,attribute（选填）<br />
    mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。<br />
    exception说明lambda表达式是否抛出异常以及何种异常。<br />
    attribute用来声明属性。</li>
<li>ret是返回值类型（拖尾返回类型）。(选填)</li>
<li>body是函数体。</li>
</ol>
<p>捕获列表：lambda表达式的捕获列表精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量。</p>
<ol>
<li>[]不捕获任何变量。</li>
<li>[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li>
<li>
<p>[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)。注意值捕获的前提是变量可以拷贝，且被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝。如果希望lambda表达式在调用时能即时访问外部变量，我们应当使用引用方式捕获。</p>
<pre><code>int a = 0;
auto f = [=] { return a; };
a+=1;
cout &lt;&lt; f() &lt;&lt; endl;       //输出0

int a = 0;
auto f = [&amp;a] { return a; };
a+=1;
cout &lt;&lt; f() &lt;&lt;endl;       //输出1
</code></pre>
</li>
<li>
<p>[=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。</p>
</li>
<li>[bar]按值捕获bar变量，同时不捕获其他变量。</li>
<li>[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&amp;或者=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。<pre><code>class A
{
public:
    int i_ = 0;

    void func(int x,int y){
        auto x1 = [] { return i_; };                   //error,没有捕获外部变量
        auto x2 = [=] { return i_ + x + y; };          //OK
        auto x3 = [&amp;] { return i_ + x + y; };          //OK
        auto x4 = [this] { return i_; };               //OK
        auto x5 = [this] { return i_ + x + y; };       //error,没有捕获x,y
        auto x6 = [this, x, y] { return i_ + x + y; }; //OK
        auto x7 = [this] { return i_++; };             //OK
    }
};
int a=0 , b=1;
auto f1 = [] { return a; };                        //error,没有捕获外部变量    
auto f2 = [&amp;] { return a++ };                      //OK
auto f3 = [=] { return a; };                       //OK
auto f4 = [=] {return a++; };                      //error,a是以复制方式捕获的，无法修改
auto f5 = [a] { return a+b; };                     //error,没有捕获变量b
auto f6 = [a, &amp;b] { return a + (b++); };           //OK
auto f7 = [=, &amp;b] { return a + (b++); };           //OK
</code></pre>
</li>
</ol>
<p>注意f4，虽然按值捕获的变量值均复制一份存储在lambda表达式变量中，修改他们也并不会真正影响到外部，但我们却仍然无法修改它们。如果希望去修改按值捕获的外部变量，需要显示指明lambda表达式为mutable。被mutable修饰的lambda表达式就算没有参数也要写明参数列表。</p>
<p>原因：lambda表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终会变为闭包类型的成员变量。按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量的值的。而mutable的作用，就在于取消operator()的const。</p>
<pre><code>int a = 0;
auto f1 = [=] { return a++; };                //error
auto f2 = [=] () mutable { return a++; };     //OK
</code></pre>
<p>lambda表达式的大致原理：每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，是一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成员。在运行时，会用复制的值初始化这些成员变量，从而生成闭包。对于引用捕获方式，无论是否标记mutable，都可以在lambda表达式中修改捕获的值。至于闭包类中是否有对应成员，C++标准中给出的答案是：不清楚的，与具体实现有关。</p>
</li>
<li>
<p>新增容器</p>
<p>std::array 保存在栈内存中，相比堆内存中的 std::vector，我们能够灵活的访问这里面的元素，从而获得更高的性能。std::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array只需指定其类型和大小即可：</p>
<pre><code>std::array&lt;int, 4&gt; arr= {1,2,3,4};
int len = 4;
std::array&lt;int, len&gt; arr = {1,2,3,4}; // 非法, 数组大小参数必须是常量表达式
</code></pre>
<p>std::forward_list 是一个列表容器，使用方法和 std::list 基本类似。<br />
和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。</p>
<p>C++11 引入了两组无序容器：<br />
std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。</p>
<p>无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)。</p>
<p>元组 std::tuple<br />
元组的使用有三个核心的函数：</p>
<ul>
<li>std::make_tuple: 构造元组</li>
<li>std::get: 获得元组某个位置的值</li>
<li>std::tie: 元组拆包</li>
</ul>
<p>元组示例：</p>
<pre><code>#include &lt;tuple&gt;
#include &lt;iostream&gt;

auto get_student(int id)
{
    // 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;
    if (id == 0)
        return std::make_tuple(3.8, 'A', "张三");
    if (id == 1)
        return std::make_tuple(2.9, 'C', "李四");
    if (id == 2)
        return std::make_tuple(1.7, 'D', "王五");
    return std::make_tuple(0.0, 'D', "null");   
    // 如果只写 0 会出现推断错误, 编译失败
}

int main()
{
    auto student = get_student(0);
    std::cout &lt;&lt; "ID: 0, "
    &lt;&lt; "GPA: " &lt;&lt; std::get&lt;0&gt;(student) &lt;&lt; ", "
    &lt;&lt; "成绩: " &lt;&lt; std::get&lt;1&gt;(student) &lt;&lt; ", "
    &lt;&lt; "姓名: " &lt;&lt; std::get&lt;2&gt;(student) &lt;&lt; '\n';

    double gpa;
    char grade;
    std::string name;

    // 元组进行拆包
    std::tie(gpa, grade, name) = get_student(1);
    std::cout &lt;&lt; "ID: 1, "
    &lt;&lt; "GPA: " &lt;&lt; gpa &lt;&lt; ", "
    &lt;&lt; "成绩: " &lt;&lt; grade &lt;&lt; ", "
    &lt;&lt; "姓名: " &lt;&lt; name &lt;&lt; '\n';
}
</code></pre>
</li>
<li>
<p>正则表达式</p>
<p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：</p>
<ol>
<li>检查一个串是否包含某种形式的子串；</li>
<li>将匹配的子串替换；</li>
<li>从某个串中取出符合条件的子串。</li>
</ol>
<p>C++11 提供的正则表达式库操作 std::string 对象，对模式 std::regex (本质是 std::basic_regex)进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch （本质是 std::match_results 对象）。</p>
</li>
<li>
<p>语言级线程支持</p>
<pre><code>std::thread
std::mutex/std::unique_lock
std::future/std::packaged_task
std::condition_variable
</code></pre>
<p>代码编译需要使用 -pthread 选项</p>
</li>
<li>
<p>右值引用和move语义</p>
<p>C++ 11引入了一种新的机制叫做“右值引用”，以便我们通过重载直接使用右值参数。我们所要做的就是写一个以右值引用为参数的构造函数：</p>
<pre><code>string(string&amp;&amp; that)   // string&amp;&amp; is an rvalue reference to a string
{
    data = that.data;
    that.data = 0;
}
</code></pre>
<p>我们没有深度拷贝堆内存中的数据，而是仅仅复制了指针，并把源对象的指针置空。事实上，我们“偷取”了属于源对象的内存数据。由于源对象是一个右值，不会再被使用，因此客户并不会觉察到源对象被改变了。在这里，我们并没有真正的复制，所以我们把这个构造函数叫做“转移构造函数”（move constructor），他的工作就是把资源从一个对象转移到另一个对象，而不是复制他们。</p>
<p>对于C++ 11，编译器会依据参数是左值还是右值在复制构造函数和转移构造函数间进行选择。</p>
<p>如果是a=b，这样就会调用复制构造函数来初始化that（因为b是左值），赋值操作符会与新创建的对象交换数据，深度拷贝。这就是copy and swap 惯用法的定义：构造一个副本，与副本交换数据，并让副本在作用域内自动销毁。这里也一样。</p>
<p>如果是a = x + y，这样就会调用转移构造函数来初始化that（因为x+y是右值），所以这里没有深度拷贝，只有高效的数据转移。相对于参数，that依然是一个独立的对象，但是他的构造函数是无用的（trivial），因此堆中的数据没有必要复制，而仅仅是转移。没有必要复制他，因为x+y是右值，再次，从右值指向的对象中转移是没有问题的。</p>
<p>总结一下：复制构造函数执行的是深度拷贝，因为源对象本身必须不能被改变。而转移构造函数却可以复制指针，把源对象的指针置空，这种形式下，这是安全的，因为用户不可能再使用这个对象了。</p>
<p>右值引用是针对右值的新的引用类型，语法是X&amp;&amp;。以前的老的引用类型X&amp; 现在被称作左值引用。使用右值引用X&amp;&amp;作为参数的最有用的函数之一就是转移构造函数X::X(X&amp;&amp; source)，它的主要作用是把源对象的本地资源转移给当前对象。</p>
<p>C++98标准库中提供了一种唯一拥有性的智能指针std::auto_ptr，该类型在C++11中已被废弃，因为其“复制”行为是危险的。C++ 11中，std::auto_ptr&lt; T &gt;已经被std::unique_ptr&lt; T &gt;所取代，后者就是利用的右值引用。其转移构造函数：</p>
<pre><code>unique_ptr(unique_ptr&amp;&amp; source)   // note the rvalue reference
{
    ptr = source.ptr;
    source.ptr = nullptr;
}
</code></pre>
<p>这个转移构造函数跟auto_ptr中复制构造函数做的事情一样，但是它却只能接受右值作为参数。</p>
<pre><code>unique_ptr&lt;Shape&gt; a(new Triangle);
unique_ptr&lt;Shape&gt; b(a);                 // error
unique_ptr&lt;Shape&gt; c(make_triangle());   // okay
</code></pre>
<p>第二行不能编译通过，因为a是左值，但是参数unique_ptr&amp;&amp; source只能接受右值，这正是我们所需要的，杜绝危险的隐式转移。第三行编译没有问题，因为make_triangle()是右值，转移构造函数会将临时对象的所有权转移给对象c，这正是我们需要的。</p>
<p>C++ 11在标准库的头文件&lt; utility &gt;中提供了一个模板函数std::move。实际上，std::move仅仅是简单地将左值转换为右值，它本身并没有转移任何东西。它仅仅是让对象可以转移。以下是如何正确的转移左值：</p>
<pre><code>unique_ptr&lt;Shape&gt; a(new Triangle);
unique_ptr&lt;Shape&gt; b(a);              // still an error
unique_ptr&lt;Shape&gt; c(std::move(a));   // okay
</code></pre>
<p>请注意，第三行之后，a不再拥有Triangle对象。不过这没有关系，因为通过明确的写出std::move(a)，我们很清楚我们的意图：亲爱的转移构造函数，你可以对a做任何想要做的事情来初始化c；我不再需要a了，对于a，您请自便。</p>
<p>当然，如果你在使用了mova(a)之后，还继续使用a，那无疑是搬起石头砸自己的脚，还是会导致严重的运行错误。</p>
<p>总之，std::move(some_lvalue)将左值转换为右值（可以理解为一种类型转换），使接下来的转移成为可能。</p>
</li>
<li>
<p>智能指针</p>
<p>C++里面的四个智能指针: auto_ptr, unique_ptr,shared_ptr, weak_ptr 其中后三个是C++11支持，并且第一个已经被C++11弃用。</p>
<ul>
<li>
<p>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>
</li>
<li>
<p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>成员函数：</p>
<ul>
<li>use_count 返回引用计数的个数</li>
<li>unique 返回是否是独占所有权( use_count 为 1)</li>
<li>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</li>
<li>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</li>
<li>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的</li>
</ul>
<p>share_ptr虽然已经很好用了，但是有一点share_ptr智能指针还是有内存泄露的情况，当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p>
</li>
<li>
<p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的shared_ptr， weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<p>weak_ptr 没有重载*和-&gt;但可以使用 lock 获得一个可用的 shared_ptr 对象. 注意, weak_ptr 在使用前需要检查合法性.</p>
<ul>
<li>expired 用于检测所管理的对象是否已经释放, 如果已经释放, 返回 true; 否则返回 false.</li>
<li>lock 用于获取所管理的对象的强引用(shared_ptr). 如果 expired 为 true, 返回一个空的 shared_ptr; 否则返回一个 shared_ptr, 其内部对象指向与 weak_ptr 相同.</li>
<li>use_count 返回与 shared_ptr 共享的对象的引用计数.</li>
<li>reset 将 weak_ptr 置空.</li>
</ul>
<p>weak_ptr 支持拷贝或赋值, 但不会影响对应的 shared_ptr 内部对象的计数.</p>
</li>
</ul>
</li>
</ol>
<h2 id="cpp20-new-features">C++ 20 新特性<a class="headerlink" href="#cpp20-new-features" title="Permanent link"></a></h2>
<h2 id="three-characteristics-of-cpp">C++ 的三大特性<a class="headerlink" href="#three-characteristics-of-cpp" title="Permanent link"></a></h2>
<p>C++的三大特性为：封装、继承和多态。</p>
<ul>
<li>封装性：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。 </li>
<li>继承：顾名思义，就像孩子会继承父母的一些性格或特点，两个类如果存在继承关系，其子类必定具有父类的相关属性（即变量）和方法（即函数）。继承的作用：避免公用代码的重复开发，减少代码和数据冗余。</li>
<li>多态：C++中有两种多态，称为 动多态（运行期多态） 和 静多态（编译期多态） ，而 静多态主要通过模板来实现，宏也是实现静多态的一种途径 。 动多态在C++中是通过虚函数实现的 ，即在基类中存在一些接口（一般为纯虚函数），子类必须重载这些接口。这样通过使用基类的指针或者引用指向子类的对象，就可以实现调用子类对应的函数的功能。动多态的函数调用机制是执行期才能进行确定，所以它是动态的。</li>
</ul>
<h2 id="polymorphism-in-cpp">C++的多态实现原理<a class="headerlink" href="#polymorphism-in-cpp" title="Permanent link"></a></h2>
<p>C++的多态性是通过迟绑定技术来实现的。</p>
<p>C++的多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p>
<h2 id="virtual-function">什么是虚函数<a class="headerlink" href="#virtual-function" title="Permanent link"></a></h2>
<h2 id="pure-virtual-function">什么是纯虚函数<a class="headerlink" href="#pure-virtual-function" title="Permanent link"></a></h2>
<h2 id="sizeof-vtable-pointer">虚表指针的大小<a class="headerlink" href="#sizeof-vtable-pointer" title="Permanent link"></a></h2>
<h2 id="vtable-pointer">虚函数表的存放内容<a class="headerlink" href="#vtable-pointer" title="Permanent link"></a></h2>
<h2 id="can-constructor-be-virtual">构造函数可以是虚函数吗<a class="headerlink" href="#can-constructor-be-virtual" title="Permanent link"></a></h2>
<p>构造函数不需要是虚函数，也不允许是虚函数。</p>
<p>虚函数的调用需要 vptr 指针，而该指针存放在对象的内容空间中，需要调用构造函数才可以创建它的值，否则即使开辟了空间，该 vptr 指针为随机值；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有 vptr 地址用来调用虚函数之一的构造函数了。</p>
<h2 id="can-destructor-be-virtual">析构函数可以是虚函数吗<a class="headerlink" href="#can-destructor-be-virtual" title="Permanent link"></a></h2>
<p>首先析构函数可以为虚函数，而且当要使用基类指针或引用调用子类时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。</p>
<p>举例说明：假设子类B继承自基类A；</p>
<pre><code class="language-cpp">A *p = new B;
delete p;
</code></pre>
<ol>
<li>此时，如果类A的析构函数不是虚函数，那么delete p；将会仅仅调用A的析构函数，只释放了B对象中的A部分，而派生出的新的部分未释放掉。</li>
<li>如果类A的析构函数是虚函数，delete p; 将会先调用B的析构函数，再调用A的析构函数，释放B对象的所有空间。</li>
</ol>
<blockquote>
<p>补充： B *p = new B; delete p;时也是先调用B的析构函数，再调用A的析构函数。</p>
</blockquote>
<h2 id="empty-class">一个空类会生成哪些函数<a class="headerlink" href="#empty-class" title="Permanent link"></a></h2>
<p>当空类Empty_one定义一个对象时Empty_one pt;sizeof(pt)仍是为1，但编译器会生成4个成员函数：</p>
<ul>
<li>一个缺省的构造函数</li>
<li>一个拷贝构造函数</li>
<li>一个析构函数</li>
<li>一个赋值运算符。</li>
</ul>
<p>这些函数只有在第一次使用它们的时候才会生成，他们都是inline并且public的。</p>
<pre><code class="language-cpp">class Empty  
{  
public:  
    Empty();                            //缺省构造函数
    Empty(const Empty &amp;rhs);            //拷贝构造函数
    ~Empty();                           //析构函数
    Empty&amp; operator=(const Empty &amp;rhs); //赋值运算符
};
</code></pre>
<h2 id="left-value-right-value">左值和右值<a class="headerlink" href="#left-value-right-value" title="Permanent link"></a></h2>
<h2 id="smart-pointer">什么是智能指针，有哪几种，作用，实现原理<a class="headerlink" href="#smart-pointer" title="Permanent link"></a></h2>
<h2 id="circular-dependency">如何避免循环依赖<a class="headerlink" href="#circular-dependency" title="Permanent link"></a></h2>
<p>若存在两个类A、B使得A类中含有B类的对象且B类中包含A类的对象，则称A、B之间存在循环依赖。</p>
<pre><code class="language-cpp">class A
{
public:
    B b;
};
class B
{
public:
    A a;
};
</code></pre>
<p>若两个类之间存在循环依赖则在编译时会报错，原因是两个类中存在相互的调用，无法为两个类分配具体的空间。</p>
<p>下面简述几个解决循环依赖的方法。</p>
<ol>
<li>
<p>使用指针代替变量声明，如</p>
<pre><code>class A
{
public:
    B *b;
};
class B
{
public:
    A *a;
};
</code></pre>
<p>这样在编译时并不会报错，因为指针类型就是四个字节，在编译时编译器知道A、B类所占内存空间的大小，故在编译时不会报错。</p>
</li>
<li>
<p>既然A、B两个类相互包含说明A、B两个类的耦合度比较高，则可以将A、B声明为一个类，然后使用派生，将A、B声明为该类的子类，修改所需的变量即可。</p>
</li>
</ol>
<h2 id="unique_ptr-stdmove">unique_ptr 中 std::move() 作用<a class="headerlink" href="#unique_ptr-stdmove" title="Permanent link"></a></h2>
<h2 id="static-keywords">static 关键字的使用<a class="headerlink" href="#static-keywords" title="Permanent link"></a></h2>
<ol>
<li>
<p>限制符号的作用域只在本程序文件</p>
<p>若变量或函数（统称符号）使用static修饰，则只能在本程序文件内使用，其他程序文件不能调用（非static的可以通过extern 关键字声明该变量是在其他文件内定义的，此文件可调用）。不加static修饰的，则默认是可以被其他程序文件调用的。</p>
</li>
<li>
<p>指定变量的存储位置</p>
<p>对于函数内的变量。auto变量（函数局部变量）都是在栈内存区存放，函数结束后就自动释放。但是全局的和函数内定义的static变量都是存放在数据区的，且只存一份，只在整个程序结束后才自动释放。
由于static变量只存一份即同一地址，所以不管函数调用多少次，函数内定义static变量的语句只会在第一次调用时执行，后面调用都不执行也不再初始化，而是对该地址内的数据进行操作。</p>
</li>
<li>
<p>C++类的静态成员变量</p>
<p>是属于类，而不属于某个实例对象，因此也只有一个地址保存一份数据存放于数据区。在类中只是声明，并不是定义，因此不分配内存，对类用sizeof求大小也不会将static变量得大小加入。
必须在类声明的外部，以及main()函数的外部，也就是全部变量区域对类的static成员变量再次定义（定以后才分配唯一内存，此时该类静态成员变量相当于是全局的静态变量了，只是调用的时候要使用类名加::）。若只定义不赋值初始化，则默认初始化为0。</p>
</li>
<li>
<p>C++类的静态成员函数</p>
<p>只能调用本类的静态成员变量或函数，不能调用本类的非静态成员函数和变量。因为非静态成员函数和变量在类成员函数中调用时，都是由形参中隐含一个指向当前实例对象的this指针来调用。然而静态成员函数没有这个this形参。</p>
</li>
</ol>
<h2 id="const-keywords">const 关键字的使用<a class="headerlink" href="#const-keywords" title="Permanent link"></a></h2>
<ol>
<li>防止被修饰的成员的内容被改变。</li>
<li>修饰类的成员函数时，表示其为一个常函数，意味着成员函数将不能修改类成员变量的值。</li>
<li>在函数声明时修饰参数，表示在函数访问时参数（包括指针和实参）的值不会发生变化。</li>
<li>对于指针而言，可以指定指针本身为const，也可以指定指针所指的数据为const，const int  <em>b = &a;或者int</em> const b = &a;修饰的都是后面的值，分别代表*b和b不能改变 。</li>
<li>const 可以替代c语言中的#define 宏定义，好处是在log中可以打印出BUFFER_SIZE 的值，而宏定义的则是不能</li>
</ol>
<pre><code class="language-cpp">#define  BUFFER_SIZE  512
const int BUFFER_SIZE   = 512;
</code></pre>
<p>注意：const数据成员必须使用成员初始化列表进行初始化。</p>
<h2 id="diffences-between-define-and-const">define 和 const 的区别<a class="headerlink" href="#diffences-between-define-and-const" title="Permanent link"></a></h2>
<ol>
<li>就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。</li>
<li>就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 </li>
<li>就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。</li>
<li>从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。</li>
</ol>
<h2 id="object-oriented-design-principles">面向对象的设计原则<a class="headerlink" href="#object-oriented-design-principles" title="Permanent link"></a></h2>
<ol>
<li>
<p>单一职责原则,一个合理的类，应该仅有一个引起它变化的原因，即单一职责,就是设计的这个类功能应该只有一个;</p>
<p>优点：消除耦合，减小因需求变化引起代码僵化。</p>
</li>
<li>
<p>开-闭原则，讲的是设计要对扩展有好的支持，而对修改要严格限制。即对扩展开放，对修改封闭。</p>
<p>优点：降低了程序各部分之间的耦合性，其适应性、灵活性、稳定性都比较好。当已有软件系统需要增加新的功能时，不需要对作为系统基础的抽象层进行修改，只需要在原有基础上附加新的模块就能实现所需要添加的功能。增加的新模块对原有的模块完全没有影响或影响很小，这样就无须为原有模块进行重新测试。</p>
</li>
<li>
<p>里氏代换原则，很严格的原则，规则是“子类必须能够替换基类，否则不应当设计为其子类。”也就是说，一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。</p>
<p>优点：可以很容易的实现同一父类下各个子类的互换，而客户端可以毫不察觉。</p>
</li>
<li>
<p>依赖倒换原则，“设计要依赖于抽象而不是具体化”。换句话说就是设计的时候我们要用抽象来思考，而不是一上来就开始划分我需要哪些哪些类，因为这些是具体。</p>
<p>“High level modules should not depend upon low level modules, both should depend upon abstractions. Abstractions should not depend upon details, details should depend upon abstractions.”</p>
<p>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p>
<p>另一种表述为： 要针对接口编程，不要针对实现编程。即“Program to an interface, not an implementation.”</p>
<p>优点：人的思维本身实际上就是很抽象的，我们分析问题的时候不是一下子就考虑到细节，而是很抽象的将整个问题都构思出来，所以面向抽象设计是符合人的思维的。另外这个原则会很好的支持（开闭原则）OCP，面向抽象的设计使我们能够不必太多依赖于实现，这样扩展就成为了可能，这个原则也是另一篇文章《Design by Contract》的基石。</p>
</li>
<li>
<p>接口隔离原则，“将大的接口打散成多个小接口”，让系统解耦，从而容易重构，更改和重新部署。</p>
<p>优点：会使一个软件系统功能扩展时，修改的压力不会传到别的对象那里。</p>
</li>
<li>
<p>迪米特法则或最少知识原则，这个原则首次在Demeter系统中得到正式运用，所以定义为迪米特法则。它讲的是“一个对象应当尽可能少的去了解其他对象”。</p>
<p>优点：消除耦合。</p>
</li>
</ol>
<p>好了，面向对象的六大原则就介绍到这里了。其实，我们不难发现，六大原则虽说是原则，但它们并不是强制性的，更多的是建议。遵照这些原则固然能帮助我们更好的规范我们的系统设计和代码习惯，但并不是所有的场景都适用，就例如接口隔离原则，在现实系统开发中，我们很难完全遵守一个模块一个接口的设计，否则业务多了就会出现代码设计过度的情况，让整个系统变得过于庞大，增加了系统的复杂度，甚至影响自己的项目进度，得不偿失啊。</p>
<p>所以，还是那句话，在合适的场景选择合适的技术！</p>
<h2 id="compilation-process">C++ 编译过程<a class="headerlink" href="#compilation-process" title="Permanent link"></a></h2>
<p>预编译处理(.c) －&gt; 编译、优化程序（.s）－&gt;汇编程序(.obj、.o、.a、.ko) －&gt; 链接程序（.exe、.elf、.axf等）</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2022 Jerry, All Rights Reserved.</p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/jquery-3.6.0.min.js"></script>
        <script src="../../js/bootstrap.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
