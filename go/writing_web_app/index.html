<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Jerry">
        <link rel="canonical" href="https://jerry-se.github.io/go/writing_web_app/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Writing Web app - Jerry's blog</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">
        <link href="../../css/extra.css" rel="stylesheet">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/django.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-274394082"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-274394082');
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Jerry's blog</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../../markdown/" class="nav-link">Markdown</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">C/C++ <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../cplusplus/lambda/" class="dropdown-item">Lambda</a>
</li>
                                    
<li>
    <a href="../../cplusplus/questions/" class="dropdown-item">Questions</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Go <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../go/" class="dropdown-item">Go tutorial</a>
</li>
                                    
<li>
    <a href="../install/" class="dropdown-item">Install</a>
</li>
                                    
<li>
    <a href="../getting_started/" class="dropdown-item">Getting started</a>
</li>
                                    
<li>
    <a href="../create_module/" class="dropdown-item">Create module</a>
</li>
                                    
<li>
    <a href="../workspaces/" class="dropdown-item">Workspaces</a>
</li>
                                    
<li>
    <a href="../web_service_gin/" class="dropdown-item">Web service gin</a>
</li>
                                    
<li>
    <a href="../generics/" class="dropdown-item">Generics</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Writing Web app</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Tool <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../git/git/" class="dropdown-item">Git</a>
</li>
                                    
<li>
    <a href="../../git/git_lfs/" class="dropdown-item">Git LFS</a>
</li>
                                    
<li>
    <a href="../../git/gitea/" class="dropdown-item">Gitea</a>
</li>
                                    
<li>
    <a href="../../tool/frp/" class="dropdown-item">Frp</a>
</li>
                                    
<li>
    <a href="../../tool/v2ray/" class="dropdown-item">V2Ray</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Python <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../python/build_blogs_with_pelican/" class="dropdown-item">Pelican</a>
</li>
                                    
<li>
    <a href="../../python/mkdocs/" class="dropdown-item">MkDocs</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Linux 开发 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../linux_development/ipmi/" class="dropdown-item">ipmi</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../generics/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../../git/git/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#write-web-applications" class="nav-link">编写 Web 应用程序</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#create-folder-for-code" class="nav-link">为您的代码创建一个文件夹</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#data-structures" class="nav-link">数据结构</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#introducing-net-http-package" class="nav-link">介绍net/http包</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#nethttpwiki" class="nav-link">用net/http服务wiki页面</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#edit-pages" class="nav-link">编辑页面</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#html-template-package" class="nav-link">html/template包</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#handling-non-existent-pages" class="nav-link">处理不存在的页面</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#saving-pages" class="nav-link">保存页面</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#error-handling" class="nav-link">错误处理</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#template-caching" class="nav-link">模板缓存</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#validation" class="nav-link">验证</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#function-literals-and-closures" class="nav-link">函数字面量和闭包</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#try-it-out" class="nav-link">测试一下</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#other-tasks" class="nav-link">其他任务</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#references" class="nav-link">参考资料</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="write-web-applications">编写 Web 应用程序<a class="headerlink" href="#write-web-applications" title="Permanent link"></a></h1>
<p>编写 Web 应用程序</p>
<hr />
<p>本教程涵盖：</p>
<ul>
<li>创建具有加载和保存方法的数据结构</li>
<li>使用<code>net/http</code>包构建 Web 应用程序</li>
<li>使用<code>html/template</code>包处理 HTML 模板</li>
<li>使用<code>regexp</code>包验证用户输入</li>
<li>使用闭包</li>
</ul>
<p>假设知识：</p>
<ul>
<li>编程经验</li>
<li>了解基本的网络技术（HTTP、HTML）</li>
<li>一些 UNIX/DOS 命令行知识</li>
</ul>
<h2 id="create-folder-for-code">为您的代码创建一个文件夹<a class="headerlink" href="#create-folder-for-code" title="Permanent link"></a></h2>
<p>在你的<code>GOPATH</code>中为本教程创建一个新目录：</p>
<pre><code class="language-shell">$ mkdir gowiki 
$ cd gowiki
</code></pre>
<p>创建一个名为 <code>wiki.go</code> 的文件，在您喜欢的编辑器中打开它，然后添加以下行：</p>
<pre><code class="language-golang">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)
</code></pre>
<p>我们从 Go 标准库中 导入<code>fmt</code>和<code>os</code>包。稍后，当我们实现附加功能时，我们将在此import声明中添加更多包。</p>
<h2 id="data-structures">数据结构<a class="headerlink" href="#data-structures" title="Permanent link"></a></h2>
<p>让我们从定义数据结构开始。一个 wiki 由一系列相互关联的页面组成，每个页面都有一个标题和一个正文（页面内容）。在这里，我们定义<code>Page</code>为一个结构体，其中包含两个字段，分别代表标题和正文。</p>
<pre><code class="language-golang">type Page struct {
    Title string
    Body  []byte
}
</code></pre>
<p>该类型的<code>[]byte</code>意思是“byte切片数组”。（有关切片的更多信息，请参阅<a href="https://go.dev/doc/articles/slices_usage_and_internals.html">切片：用法和内部</a>。）<code>Body</code>元素是 <code>[]byte</code>而不是 <code>string</code>，因为这是我们将使用的<code>io</code>库所期望的类型，如下所示。</p>
<p>该<code>Page</code>结构描述了页面数据将如何存储在内存中。但是持久存储呢？我们可以通过在<code>Page</code>上创建一个 <code>save</code>方法来解决这个问题：</p>
<pre><code class="language-golang">func (p *Page) save() error {
    filename := p.Title + &quot;.txt&quot;
    return os.WriteFile(filename, p.Body, 0600)
}
</code></pre>
<p>这个方法的签名写着：“这是一个名为<code>save</code>的方法，它的接收者p是一个指向<code>Page</code>的指针。它不接受任何参数，并返回一个<code>error</code>类型的值。”</p>
<p>此方法会将<code>Page's Body</code>保存到文本文件中。为简单起见，我们将使用<code>Title</code>作为文件名。</p>
<p>该<code>save</code>方法返回一个<code>error</code>值，因为这是<code>WriteFile</code>（将字节切片写入文件的标准库函数）的返回类型。该<code>save</code>方法返回错误值，让应用程序在写入文件出现任何问题时处理它。如果一切顺利，<code>Page.save()</code>将返回 <code>nil</code>（指针、接口和其他一些类型的零值）。</p>
<p>八进制整数文字<code>0600</code>，作为第三个参数传递给 <code>WriteFile</code>，表示创建文件时应仅对当前用户具有读写权限。（有关详细信息，请参见 Unix man page <code>open(2)</code>。）</p>
<p>除了保存页面，我们还需要加载页面：</p>
<pre><code class="language-golang">func loadPage(title string) *Page {
    filename := title + &quot;.txt&quot;
    body, _ := os.ReadFile(filename)
    return &amp;Page{Title: title, Body: body}
}
</code></pre>
<p>该函数<code>loadPage</code>从 <code>title</code> 参数构造文件名，将文件的内容读入一个新变量<code>body</code>，并返回一个指针，指向由正确的标题和正文值构造的<code>Page</code>。</p>
<p>函数可以返回多个值。标准库函数 <code>os.ReadFile</code>返回<code>[]byte</code>和<code>error</code>。在<code>loadPage</code>中，尚未处理错误；下划线(_) 符号表示的“空白标识符”用于丢弃错误返回值（本质上，将值赋值为空）。</p>
<p>但是如果<code>ReadFile</code>遇到错误会发生什么？例如，该文件可能不存在。我们不应该忽视这样的错误。让我们修改函数以返回<code>*Page</code>和<code>error</code>。</p>
<pre><code class="language-golang">func loadPage(title string) (*Page, error) {
    filename := title + &quot;.txt&quot;
    body, err := os.ReadFile(filename)
    if err != nil {
        return nil, err
    }
    return &amp;Page{Title: title, Body: body}, nil
}
</code></pre>
<p>该函数的调用者现在可以检查第二个参数；如果是<code>nil</code>则它已成功加载页面。如果不是，它将是可以由调用者处理的 <code>error</code>（有关详细信息，请参阅 <a href="https://go.dev/ref/spec#Errors">语言规范</a>）。</p>
<p>在这一点上，我们有一个简单的数据结构和保存到文件和从文件加载的能力。让我们编写一个<code>main</code>函数来测试我们所写的内容：</p>
<pre><code class="language-golang">func main() {
    p1 := &amp;Page{Title: &quot;TestPage&quot;, Body: []byte(&quot;This is a sample Page.&quot;)}
    p1.save()
    p2, _ := loadPage(&quot;TestPage&quot;)
    fmt.Println(string(p2.Body))
}
</code></pre>
<p>编译并执行此代码后，将创建一个名为 <code>TestPage.txt</code> 的文件，包含<code>p1</code>的正文。然后将文件读入结构体 <code>p2</code>，并将其<code>Body</code>元素打印到屏幕上。</p>
<p>您可以像这样编译和运行程序：</p>
<pre><code class="language-shell">$ go build wiki.go
$ ./wiki
This is a sample Page.
</code></pre>
<p>（如果您使用的是 Windows，则必须键入不带<code>“./”</code>的<code>“wiki”</code>才能运行程序。）</p>
<p><a href="../wiki/part1.go/">单击此处查看到目前为止我们编写的代码。</a></p>
<h2 id="introducing-net-http-package">介绍<code>net/http</code>包<a class="headerlink" href="#introducing-net-http-package" title="Permanent link"></a></h2>
<p>这是一个简单 Web 服务器的完整工作示例：</p>
<pre><code class="language-golang">//go:build ignore

package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &quot;Hi there, I love %s!&quot;, r.URL.Path[1:])
}

func main() {
    http.HandleFunc(&quot;/&quot;, handler)
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}
</code></pre>
<p>该<code>main</code>函数以对 <code>http.HandleFunc</code> 的调用开始，它告诉<code>http</code>程序包使用<code>handler</code>函数处理对 Web 根(<code>"/"</code>)的所有请求。</p>
<p>然后它调用<code>http.ListenAndServe</code>，指定它应该在任何接口 (<code>":8080"</code>) 上侦听端口 <code>8080</code>。（暂时不要担心它的第二个参数<code>nil</code>。）这个函数将一直阻塞，直到程序终止。</p>
<p><code>ListenAndServe</code>总是返回一个错误，因为它只在发生意外错误时返回。为了记录该错误，我们将在函数<code>log.Fatal</code>中调用。</p>
<p>该函数<code>handler</code>的类型为<code>http.HandlerFunc</code>。它以 <code>http.ResponseWriter</code>和 <code>http.Request</code>作为参数。</p>
<p>一个<code>http.ResponseWriter</code>值组合了 HTTP 服务器的响应；通过写入它，我们将数据发送到 HTTP 客户端。</p>
<p><code>http.Request</code>是表示客户端 HTTP 请求的数据结构。<code>r.URL.Path</code>是请求 URL 的路径组件。尾随<code>[1:]</code>意味着“创建从<code>Path</code>的第一个字符到结尾的子切片”。这会从路径名中删除前导“/”。</p>
<p>如果您运行此程序并访问 URL：</p>
<pre><code>http://localhost:8080/monkeys
</code></pre>
<p>该程序将显示一个页面，其中包含：</p>
<pre><code>Hi there, I love monkeys!
</code></pre>
<h2 id="nethttpwiki" using-net-http-package="using-net-http-package">用<code>net/http</code>服务<code>wiki</code>页面<a class="headerlink" href="#nethttpwiki" title="Permanent link"></a></h2>
<p>要使用该<code>net/http</code>包，必须将其导入：</p>
<pre><code class="language-golang">import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)
</code></pre>
<p>让我们创建一个处理程序，<code>viewHandler</code>它允许用户查看 wiki 页面。它将处理以“/view/”为前缀的 URL。</p>
<pre><code class="language-golang">func viewHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len(&quot;/view/&quot;):]
    p, _ := loadPage(title)
    fmt.Fprintf(w, &quot;&lt;h1&gt;%s&lt;/h1&gt;&lt;div&gt;%s&lt;/div&gt;&quot;, p.Title, p.Body)
}
</code></pre>
<p>再次注意使用<code>_</code>忽略来自<code>loadPage</code>的返回值<code>error</code>。这是为了简单起见，通常被认为是不好的做法。我们稍后会处理这个问题。</p>
<p>首先，此函数从请求 URL 的路径组件 <code>r.URL.Path</code> 中提取页面标题。使用<code>[len("/view/"):]</code>将<code>Path</code>重新切片以删除请求路径的前导<code>"/view/"</code>组件。这是因为路径总是以 <code>"/view/"</code> 开头，它不是页面标题的一部分。</p>
<p>然后该函数加载页面数据，用一串简单的 HTML 格式化页面，并将其写入<code>http.ResponseWriter</code>对象<code>w</code>.</p>
<p>要使用这个处理程序，我们重写我们的<code>main</code>函数来初始化<code>http</code>使用<code>viewHandler</code>来处理<code>/view/</code>路径下的任何请求。</p>
<pre><code class="language-golang">func main() {
    http.HandleFunc(&quot;/view/&quot;, viewHandler)
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}
</code></pre>
<p><a href="../wiki/part2.go/">单击此处查看到目前为止我们编写的代码。</a></p>
<p>让我们创建一些页面数据（保存为 <code>test.txt</code>），编译我们的代码，并尝试提供一个 wiki 页面。</p>
<p>在编辑器中打开<code>test.txt</code>文件，并在其中保存字符串“Hello world”（不带引号）。</p>
<pre><code class="language-shell">$ go build wiki.go
$ ./wiki
</code></pre>
<p>（如果您使用的是 Windows，则必须键入不带<code>“./”</code>的<code>“wiki”</code>才能运行程序。）</p>
<p>随着这个网络服务器的运行，访问 <a href="http://localhost:8080/view/test">http://localhost:8080/view/test</a> 应该会显示一个标题为“test”的页面，其中包含“Hello world”这个词。</p>
<h2 id="edit-pages">编辑页面<a class="headerlink" href="#edit-pages" title="Permanent link"></a></h2>
<p>wiki 不能没有编辑页面的能力。让我们创建两个新的处理程序：一个命名<code>editHandler</code>为显示“编辑页面”表单，另一个命名<code>saveHandler</code>为保存通过表单输入的数据。</p>
<p>首先，我们将它们添加到<code>main()</code>：</p>
<pre><code class="language-golang">func main() {
    http.HandleFunc(&quot;/view/&quot;, viewHandler)
    http.HandleFunc(&quot;/edit/&quot;, editHandler)
    http.HandleFunc(&quot;/save/&quot;, saveHandler)
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}
</code></pre>
<p>函数<code>editHandler</code>加载页面（如果它不存在，则创建一个空<code>Page</code>结构），并显示一个 HTML 表单。</p>
<pre><code class="language-golang">func editHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len(&quot;/edit/&quot;):]
    p, err := loadPage(title)
    if err != nil {
        p = &amp;Page{Title: title}
    }
    fmt.Fprintf(w, &quot;&lt;h1&gt;Editing %s&lt;/h1&gt;&quot;+
        &quot;&lt;form action=\&quot;/save/%s\&quot; method=\&quot;POST\&quot;&gt;&quot;+
        &quot;&lt;textarea name=\&quot;body\&quot;&gt;%s&lt;/textarea&gt;&lt;br&gt;&quot;+
        &quot;&lt;input type=\&quot;submit\&quot; value=\&quot;Save\&quot;&gt;&quot;+
        &quot;&lt;/form&gt;&quot;,
        p.Title, p.Title, p.Body)
}
</code></pre>
<p>这个函数可以正常工作，但所有硬编码的 HTML 都很丑陋。当然，还有更好的方法。</p>
<h2 id="html-template-package"><code>html/template</code>包<a class="headerlink" href="#html-template-package" title="Permanent link"></a></h2>
<p>该<code>html/template</code>包是 Go 标准库的一部分。我们可以使用<code>html/template</code>将 HTML 保存在单独的文件中，允许我们更改编辑页面的布局，而无需修改底层 Go 代码。</p>
<p>首先，我们必须添加<code>html/template</code>到导入列表中。我们也不会再使用<code>fmt</code>了，所以我们必须删除它。</p>
<pre><code class="language-golang">import (
    &quot;html/template&quot;
    &quot;os&quot;
    &quot;net/http&quot;
)
</code></pre>
<p>让我们创建一个包含 HTML 表单的模板文件。打开一个名为 <code>edit.html</code> 的新文件，并添加以下行：</p>
<pre><code class="language-html">&lt;h1&gt;Editing {{.Title}}&lt;/h1&gt;

&lt;form action=&quot;/save/{{.Title}}&quot; method=&quot;POST&quot;&gt;
&lt;div&gt;&lt;textarea name=&quot;body&quot; rows=&quot;20&quot; cols=&quot;80&quot;&gt;{{printf &quot;%s&quot; .Body}}&lt;/textarea&gt;&lt;/div&gt;
&lt;div&gt;&lt;input type=&quot;submit&quot; value=&quot;Save&quot;&gt;&lt;/div&gt;
&lt;/form&gt;
</code></pre>
<p>修改<code>editHandler</code>以使用模板，而不是硬编码的 HTML：</p>
<pre><code class="language-golang">func editHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len(&quot;/edit/&quot;):]
    p, err := loadPage(title)
    if err != nil {
        p = &amp;Page{Title: title}
    }
    t, _ := template.ParseFiles(&quot;edit.html&quot;)
    t.Execute(w, p)
}
</code></pre>
<p>函数<code>template.ParseFiles</code>将读取<code>edit.html</code>的内容并返回一个<code>*template.Template</code>.</p>
<p>方法<code>t.Execute</code>执行模板，将生成的 HTML 写入<code>http.ResponseWriter</code>。带点的<code>.Title</code>和<code>.Body</code>标识符指的是<code>p.Title</code>和<code>p.Body</code>。</p>
<p>模板指令用双花括号括起来。该<code>printf "%s" .Body</code>指令是一个函数调用，它以字符串输出<code>.Body</code>而不是字节流的形式，类似于调用<code>fmt.Printf</code>。该<code>html/template</code>包有助于确保模板操作仅生成安全且外观正确的 HTML。例如，它会自动转义任何大于号(<code>&gt;</code>)，将其替换为<code>&amp;gt;</code>，以确保用户数据不会破坏 HTML 表单。</p>
<p>由于我们现在正在使用模板，让我们为<code>viewHandler</code>调用的<code>view.html</code>创建一个模板：</p>
<pre><code class="language-html">&lt;h1&gt;{{.Title}}&lt;/h1&gt;

&lt;p&gt;[&lt;a href=&quot;/edit/{{.Title}}&quot;&gt;edit&lt;/a&gt;]&lt;/p&gt;

&lt;div&gt;{{printf &quot;%s&quot; .Body}}&lt;/div&gt;
</code></pre>
<p>对应修改<code>viewHandler</code>：</p>
<pre><code class="language-golang">func viewHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len(&quot;/view/&quot;):]
    p, _ := loadPage(title)
    t, _ := template.ParseFiles(&quot;view.html&quot;)
    t.Execute(w, p)
}
</code></pre>
<p>请注意，我们在两个处理程序中使用了几乎完全相同的模板代码。让我们通过将模板代码移动到它自己的函数来删除这个重复：</p>
<pre><code class="language-golang">func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {
    t, _ := template.ParseFiles(tmpl + &quot;.html&quot;)
    t.Execute(w, p)
}
</code></pre>
<p>并修改处理程序以使用该函数：</p>
<pre><code class="language-golang">func viewHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len(&quot;/view/&quot;):]
    p, _ := loadPage(title)
    renderTemplate(w, &quot;view&quot;, p)
}
</code></pre>
<pre><code class="language-golang">func editHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len(&quot;/edit/&quot;):]
    p, err := loadPage(title)
    if err != nil {
        p = &amp;Page{Title: title}
    }
    renderTemplate(w, &quot;edit&quot;, p)
}
</code></pre>
<p>如果我们在 <code>main</code> 中注释掉未实现的保存处理程序(saveHandler)的注册，我们可以再次构建和测试我们的程序。<a href="../wiki/part3.go/">单击此处查看到目前为止我们编写的代码。</a></p>
<h2 id="handling-non-existent-pages">处理不存在的页面<a class="headerlink" href="#handling-non-existent-pages" title="Permanent link"></a></h2>
<p>如果你访问 <a href="http://localhost:8080/view/APageThatDoesntExist">http://localhost:8080/view/APageThatDoesntExist</a> 您将看到一个包含 HTML 的页面。这是因为它忽略了错误返回值，并继续尝试填写没有数据的模板。相反，如果请求的页面不存在，它应该将客户端重定向到编辑页面，以便可以创建内容：</p>
<pre><code class="language-golang">func viewHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len(&quot;/view/&quot;):]
    p, err := loadPage(title)
    if err != nil {
        http.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)
        return
    }
    renderTemplate(w, &quot;view&quot;, p)
}
</code></pre>
<p>函数 <code>http.Redirect</code> 向 HTTP 响应 添加 HTTP 状态代码 <code>http.StatusFound(302)</code> 和标头 <code>Location</code>。</p>
<h2 id="saving-pages">保存页面<a class="headerlink" href="#saving-pages" title="Permanent link"></a></h2>
<p>函数<code>saveHandler</code>将处理位于编辑页面上的表单的提交。取消注释<code>main</code>中的相关行后，让我们实现处理程序：</p>
<pre><code class="language-golang">func saveHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len(&quot;/save/&quot;):]
    body := r.FormValue(&quot;body&quot;)
    p := &amp;Page{Title: title, Body: []byte(body)}
    p.save()
    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)
}
</code></pre>
<p>页面标题（在 URL 中提供）和表单的唯一字段 <code>Body</code>存储在一个新的<code>Page</code>。然后调用该<code>save()</code>方法将数据写入文件，并将客户端重定向到<code>/view/</code>页面。</p>
<p><code>FormValue</code>返回的值类型是<code>string</code>。我们必须将该值转换为 <code>[]byte</code>，然后才能将其放入<code>Page</code>结构中。我们用<code>[]byte(body)</code>来执行转换。</p>
<h2 id="error-handling">错误处理<a class="headerlink" href="#error-handling" title="Permanent link"></a></h2>
<p>在我们的程序中有几个地方会忽略错误。这是不好的做法，尤其是因为当确实发生错误时，程序会出现意外行为。更好的解决方案是处理错误并将错误消息返回给用户。这样，如果出现问题，服务器将完全按照我们想要的方式运行，并且可以通知用户。</p>
<p>首先，让我们处理<code>renderTemplate</code>中的错误：</p>
<pre><code class="language-golang">func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {
    t, err := template.ParseFiles(tmpl + &quot;.html&quot;)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    err = t.Execute(w, p)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
    }
}
</code></pre>
<p><code>http.Error</code>函数发送指定的 HTTP 响应代码（在本例中为“内部服务器错误”）和错误消息。将它放在一个单独的函数中的决定已经得到了回报。</p>
<p>现在让我们修复<code>saveHandler</code>：</p>
<pre><code class="language-golang">func saveHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len(&quot;/save/&quot;):]
    body := r.FormValue(&quot;body&quot;)
    p := &amp;Page{Title: title, Body: []byte(body)}
    err := p.save()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)
}
</code></pre>
<p><code>p.save()</code>期间发生的任何错误都会报告给用户。</p>
<h2 id="template-caching">模板缓存<a class="headerlink" href="#template-caching" title="Permanent link"></a></h2>
<p>这段代码效率低下：每次渲染页面时<code>renderTemplate</code>都会调用<code>ParseFiles</code>。更好的方法是<code>ParseFiles</code>在程序初始化时调用一次，将所有模板解析为单个<code>*Template</code>。然后我们可以使用 <code>ExecuteTemplate</code> 方法来渲染特定的模板。</p>
<p>首先，我们创建一个名为 <code>templates</code> 的全局变量，并用 <code>ParseFiles</code> 对其进行初始化。</p>
<pre><code class="language-golang">var templates = template.Must(template.ParseFiles(&quot;edit.html&quot;, &quot;view.html&quot;))
</code></pre>
<p>函数<code>template.Must</code>是一个方便的包装器，当传递一个非零<code>error</code>值时会发生恐慌(panic)，否则返回未更改的值<code>*Template</code>。恐慌在这里是合适的；如果无法加载模板，唯一明智的做法是退出程序。</p>
<p><code>ParseFiles</code>函数采用任意数量的字符串参数来标识我们的模板文件，并将这些文件解析为以基本文件名命名的模板。如果我们要在程序中添加更多模板，我们会将它们的名称添加到<code>ParseFiles</code>调用的参数中。</p>
<p>然后我们修改<code>renderTemplate</code>函数以使用适当模板的名称作参数调用<code>templates.ExecuteTemplate</code>方法：</p>
<pre><code class="language-golang">func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {
    err := templates.ExecuteTemplate(w, tmpl+&quot;.html&quot;, p)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
    }
}
</code></pre>
<p>请注意，模板名称是模板文件名，因此我们必须附加<code>".html"</code>到<code>tmpl</code>参数中。</p>
<h2 id="validation">验证<a class="headerlink" href="#validation" title="Permanent link"></a></h2>
<p>正如您可能已经观察到的，该程序有一个严重的安全漏洞：用户可以提供任意路径以在服务器上读取/写入。为了缓解这种情况，我们可以编写一个函数来使用正则表达式验证标题。</p>
<p>首先，添加<code>"regexp"</code>到<code>import</code>列表中。然后我们可以创建一个全局变量来存储我们的验证表达式：</p>
<pre><code class="language-golang">var validPath = regexp.MustCompile(&quot;^/(edit|save|view)/([a-zA-Z0-9]+)$&quot;)
</code></pre>
<p>函数<code>regexp.MustCompile</code>将解析和编译正则表达式，并返回一个<code>regexp.Regexp</code>。<code>MustCompile</code>与<code>Compile</code>不同之处在于，如果表达式编译失败，它将恐慌(panic)，而<code>Compile</code>会返回一个<code>error</code>作为第二个参数。</p>
<p>现在，让我们编写一个函数，使用<code>validPath</code>表达式来验证路径并提取页面标题：</p>
<pre><code class="language-golang">func getTitle(w http.ResponseWriter, r *http.Request) (string, error) {
    m := validPath.FindStringSubmatch(r.URL.Path)
    if m == nil {
        http.NotFound(w, r)
        return &quot;&quot;, errors.New(&quot;invalid Page Title&quot;)
    }
    return m[2], nil // The title is the second subexpression.
}
</code></pre>
<p>如果标题有效，它将与<code>nil</code>错误值一起返回。如果标题无效，该函数将向 HTTP 连接写入“404 Not Found”错误，并向处理程序返回错误。要创建新错误，我们必须导入<code>errors</code>包。</p>
<p>让我们在每个处理程序中调用<code>getTitle</code>：</p>
<pre><code class="language-golang">func viewHandler(w http.ResponseWriter, r *http.Request) {
    title, err := getTitle(w, r)
    if err != nil {
        return
    }
    p, err := loadPage(title)
    if err != nil {
        http.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)
        return
    }
    renderTemplate(w, &quot;view&quot;, p)
}
</code></pre>
<pre><code class="language-golang">func editHandler(w http.ResponseWriter, r *http.Request) {
    title, err := getTitle(w, r)
    if err != nil {
        return
    }
    p, err := loadPage(title)
    if err != nil {
        p = &amp;Page{Title: title}
    }
    renderTemplate(w, &quot;edit&quot;, p)
}
</code></pre>
<pre><code class="language-golang">func saveHandler(w http.ResponseWriter, r *http.Request) {
    title, err := getTitle(w, r)
    if err != nil {
        return
    }
    body := r.FormValue(&quot;body&quot;)
    p := &amp;Page{Title: title, Body: []byte(body)}
    err = p.save()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)
}
</code></pre>
<h2 id="function-literals-and-closures">函数字面量和闭包<a class="headerlink" href="#function-literals-and-closures" title="Permanent link"></a></h2>
<p>在每个处理程序中捕获错误条件会引入大量重复代码。如果我们可以将每个处理程序包装在一个执行此验证和错误检查的函数中怎么办？Go 的 <a href="https://go.dev/ref/spec#Function_literals">函数字面量</a> 提供了一种强大的抽象功能的方法，可以在这里为我们提供帮助。</p>
<p>首先，我们重写每个处理程序的函数定义以接受标题字符串：</p>
<pre><code class="language-golang">func viewHandler(w http.ResponseWriter, r *http.Request, title string)
func editHandler(w http.ResponseWriter, r *http.Request, title string)
func saveHandler(w http.ResponseWriter, r *http.Request, title string)
</code></pre>
<p>现在让我们定义一个包装函数，它接受上述类型的函数，并返回一个<code>http.HandlerFunc</code>类型的函数（适合传递给函数<code>http.HandleFunc</code>）：</p>
<pre><code class="language-golang">func makeHandler(fn func (http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // Here we will extract the page title from the Request,
        // and call the provided handler 'fn'
    }
}
</code></pre>
<p>返回的函数称为<strong>闭包</strong>，因为它包含在其外部定义的值。在这种情况下，变量<code>fn</code>（<code>makeHandler</code>的单个参数）由闭包包围。该变量<code>fn</code>将是我们的保存、编辑或查看的处理程序之一。</p>
<p>现在我们可以从<code>getTitle</code>中获取代码并在此处使用它（稍作修改）：</p>
<pre><code class="language-golang">func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        m := validPath.FindStringSubmatch(r.URL.Path)
        if m == nil {
            http.NotFound(w, r)
            return
        }
        fn(w, r, m[2])
    }
}
</code></pre>
<p><code>makeHandler</code>返回的闭包是一个接受<code>http.ResponseWriter</code>和<code>http.Request</code>（换句话说，一个<code>http.HandlerFunc</code>）参数的函数。闭包从请求路径中提取<code>title</code>，并使用正则表达式<code>validPath</code>对其进行验证。如果<code>title</code>无效，将使用<code>http.NotFound</code>函数向<code>ResponseWriter</code>写入错误。如果<code>title</code>有效，则使用<code>ResponseWriter</code>、<code>Request</code>和<code>title</code>作为参数调用封闭的处理函数<code>fn</code>。</p>
<p>现在我们可以在<code>main</code>中用<code>makeHandler</code>包装处理函数，然后再将它们注册到<code>http</code>包中：</p>
<pre><code class="language-golang">func main() {
    http.HandleFunc(&quot;/view/&quot;, makeHandler(viewHandler))
    http.HandleFunc(&quot;/edit/&quot;, makeHandler(editHandler))
    http.HandleFunc(&quot;/save/&quot;, makeHandler(saveHandler))

    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}
</code></pre>
<p>最后，我们从处理函数中删除对<code>getTitle</code>的调用，使它们更简单：</p>
<pre><code class="language-golang">func viewHandler(w http.ResponseWriter, r *http.Request, title string) {
    p, err := loadPage(title)
    if err != nil {
        http.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)
        return
    }
    renderTemplate(w, &quot;view&quot;, p)
}
</code></pre>
<pre><code class="language-golang">func editHandler(w http.ResponseWriter, r *http.Request, title string) {
    p, err := loadPage(title)
    if err != nil {
        p = &amp;Page{Title: title}
    }
    renderTemplate(w, &quot;edit&quot;, p)
}
</code></pre>
<pre><code class="language-golang">func saveHandler(w http.ResponseWriter, r *http.Request, title string) {
    body := r.FormValue(&quot;body&quot;)
    p := &amp;Page{Title: title, Body: []byte(body)}
    err := p.save()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)
}
</code></pre>
<h2 id="try-it-out">测试一下<a class="headerlink" href="#try-it-out" title="Permanent link"></a></h2>
<p><a href="../wiki/final.go/">单击此处查看最终代码清单。</a></p>
<p>重新编译代码，然后运行应用程序：</p>
<pre><code class="language-bash">$ go build wiki.go
$ ./wiki
</code></pre>
<p>访问 <a href="http://localhost:8080/view/ANewPage">http://localhost:8080/view/ANewPage</a> 应该会显示页面编辑表单。然后，您应该能够输入一些文本，单击“保存”，然后被重定向到新创建的页面。</p>
<h2 id="other-tasks">其他任务<a class="headerlink" href="#other-tasks" title="Permanent link"></a></h2>
<p>以下是您可能希望自己解决的一些简单任务：</p>
<ul>
<li>将模板存储在<code>tmpl/</code>中，将页面数据存储在<code>data/</code>中。</li>
<li>添加一个处理程序以使 Web 根重定向到 <code>/view/FrontPage</code>。</li>
<li>通过使它们成为有效的 HTML 并添加一些 CSS 规则来美化页面模板。</li>
<li>通过将<code>[PageName]</code>的实例转换为 <code>&lt;a href="/view/PageName"&gt;PageName&lt;/a&gt;</code>（提示：你可以用<code>regexp.ReplaceAllFunc</code>来做这个） 来实现页面间链接。</li>
</ul>
<h2 id="references">参考资料<a class="headerlink" href="#references" title="Permanent link"></a></h2>
<p><a href="https://go.dev/doc/articles/wiki/">https://go.dev/doc/articles/wiki/</a></p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2022 Jerry, All Rights Reserved.</p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
